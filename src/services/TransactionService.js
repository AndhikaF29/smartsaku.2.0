import { supabaseClient } from './supabaseClient.js';

class TransactionService {
    static async getUserTransactions(userId) {
        try {
            const { data, error } = await supabaseClient
                .from('transactions')
                .select('*')
                .eq('user_id', userId)
                .order('tanggal', { ascending: false });

            if (error) {
                console.error('Error fetching transactions:', error);
                throw error;
            }

            return data || [];
        } catch (error) {
            console.error('Transaction service error:', error);
            throw new Error('Failed to get transactions');
        }
    }

    static async createTransaction(transactionData) {
        try {
            // Remove id if present (it will be generated by Supabase)
            if (transactionData.id) {
                delete transactionData.id;
            }
            
            // Convert nominal to numeric if it's not
            if (typeof transactionData.nominal !== 'number') {
                transactionData.nominal = parseFloat(transactionData.nominal);
            }

            // Ensure tanggal is in the right format (YYYY-MM-DD)
            if (transactionData.tanggal && !transactionData.tanggal.match(/^\d{4}-\d{2}-\d{2}$/)) {
                const date = new Date(transactionData.tanggal);
                transactionData.tanggal = date.toISOString().split('T')[0];
            }

            // Remove created_at if present (it will be generated by Supabase)
            if (transactionData.created_at) {
                delete transactionData.created_at;
            }

            const { data, error } = await supabaseClient
                .from('transactions')
                .insert([transactionData])
                .select();

            if (error) {
                console.error('Error creating transaction:', error);
                throw error;
            }

            return data ? data[0] : null;
        } catch (error) {
            console.error('Transaction service error:', error);
            throw new Error('Failed to create transaction');
        }
    }

    static async getFinancialSummary(userId) {
        try {
            // Get all transactions for the user
            const { data: transactions, error } = await supabaseClient
                .from('transactions')
                .select('jenis, nominal')
                .eq('user_id', userId);

            if (error) {
                console.error('Error fetching financial summary:', error);
                throw error;
            }

            // Calculate totals
            let totalPemasukan = 0;
            let totalPengeluaran = 0;
            
            (transactions || []).forEach(transaction => {
                if (transaction.jenis === 'pemasukan') {
                    totalPemasukan += parseFloat(transaction.nominal);
                } else if (transaction.jenis === 'pengeluaran') {
                    totalPengeluaran += parseFloat(transaction.nominal);
                }
            });

            // Get transaction count for current month
            const now = new Date();
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];
            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).toISOString().split('T')[0];

            const { count, error: countError } = await supabaseClient
                .from('transactions')
                .select('*', { count: 'exact', head: true })
                .eq('user_id', userId)
                .gte('tanggal', startOfMonth)
                .lte('tanggal', endOfMonth);

            if (countError) {
                console.error('Error getting transaction count:', countError);
            }

            return {
                totalSaldo: totalPemasukan - totalPengeluaran,
                totalPemasukan,
                totalPengeluaran,
                totalTransaksi: count || 0
            };
        } catch (error) {
            console.error('Error calculating financial summary:', error);
            throw new Error('Failed to calculate financial summary');
        }
    }

    static async updateTransaction(id, transactionData) {
        try {
            const { data, error } = await supabaseClient
                .from('transactions')
                .update(transactionData)
                .eq('id', id)
                .select();

            if (error) {
                console.error('Error updating transaction:', error);
                throw error;
            }

            return data ? data[0] : null;
        } catch (error) {
            console.error('Transaction service error:', error);
            throw new Error('Failed to update transaction');
        }
    }

    static async deleteTransaction(id) {
        try {
            const { error } = await supabaseClient
                .from('transactions')
                .delete()
                .eq('id', id);

            if (error) {
                console.error('Error deleting transaction:', error);
                throw error;
            }

            return true;
        } catch (error) {
            console.error('Transaction service error:', error);
            throw new Error('Failed to delete transaction');
        }
    }

    static async getCategoryBreakdown(userId, startDate, endDate) {
        try {
            let query = supabaseClient
                .from('transactions')
                .select('kategori, nominal, jenis')
                .eq('user_id', userId)
                .eq('jenis', 'pengeluaran');

            if (startDate) {
                query = query.gte('tanggal', startDate);
            }

            if (endDate) {
                query = query.lte('tanggal', endDate);
            }

            const { data, error } = await query;

            if (error) {
                console.error('Error fetching category breakdown:', error);
                throw error;
            }

            // Group by category
            const categoryTotals = {};
            (data || []).forEach(transaction => {
                const category = transaction.kategori;
                if (!categoryTotals[category]) {
                    categoryTotals[category] = 0;
                }
                categoryTotals[category] += parseFloat(transaction.nominal);
            });

            return categoryTotals;
        } catch (error) {
            console.error('Error calculating category breakdown:', error);
            throw new Error('Failed to calculate category breakdown');
        }
    }
}

export default TransactionService;